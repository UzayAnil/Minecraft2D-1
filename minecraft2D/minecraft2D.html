<title>UTL > Minecraft 2D</title>
<div style="background-color:red;color:white;" align="center" id="error:texture" hidden><h1>ERROR: Some textures failed to load.</h1></div>
<br>
<h1>Minecraft 2D Release! (v1.0.3)</h1>
<br>
Enter world code / get world code (Please start the game FIRST!):
<br>
<button onclick="loadWorld();" disabled id="loadWorldE">Load Code</button><button onclick="getWorld();" disabled id="getWorldE">Get Code</button>
<br>
<textarea id="textWorldE" placeholder="Inset your world code here!"></textarea>
<br>
<button onclick="loadMod();" id="loadModE">Load Mod</button>
<br>
<textarea id="modText" placeholder="Insert your mod here!"></textarea>
<br>
Changelog below... (And links at bottom of page.)
<br>
<p id="randText">RandomText Error 1</p>
<br>
The mod tick button works the same as start game, but allows alteration of game speed. Will be removed.
<br>
Clicking the crop screen button allows touchscreen to be used more easly! Sorry no zoom.
<br>
<button onclick="Game.canvas.width = 500;Game.canvas.height = 500;start();loadWorldE.disabled = false;getWorldE.disabled = false;loadModE.disabled = true;">Start Game!</button><button onclick="modTick();loadWorldE.disabled = false;getWorldE.disabled = false;loadModE.disabled = true;">MOD Tick</button><button onclick="start();Game.canvas.height = screen.height;Game.canvas.width = screen.width;">Crop Screen (Large)</button><button onclick="start();Game.canvas.height = screen.height/2;Game.canvas.width = screen.width/2;">Crop Screen (Small)</button>
<br>
DEBUG (Messing with these settings may cause problems, they can be reset by reloading the page.)
<br>
<button onclick="debug.innerHTML = 'Function completed in '+Game.debug.checkFunctionPerformance(update)+'ms';">UPDATE()</button>
<br>
Debug Result:
<br>
<textarea id="debug" placeholder="No results yet..."></textarea>
<br>
<a href="javascript:Game.canvas.requestFullscreen();">Fullscreen</a> - Please note that fullscreen disables touchscreen acuracy. You may have trouble using touchscreen.
<br>

<canvas id="gameWindow" onclick="window.click = 1;setTimeout(clickUp,tickSpeed+5);" width=500 height=500 style="border-color:gray;border-style:solid;border-width:5px;cursor: none;" onmousemove="getMouse(event)">

</canvas>
<br>
Bugs:
<h1>---</h1>
-Brightness lag.<br>
-Some arrow keys don't work<br>
-Async world generation does not work.
<h1>---</h1>
Changelog:
<h1>Release v1.0.0</h1>
-Created motion and hitbox. And dirt wood air and grass blocks.
-Created a block API. (NOT DONE!)<br>
-As of currently the bottom of blocks is semi-solid, it will not block jumping.<br>
-Infinite world sizes!<br>
-Also added a very rare chance to get a pink tree!<br>
-There are other rare things not listed...<br>
-Chunks save data every time you leave.<br>
-Fixed chunk array duplication. (Basicly chunks saved really weird and duplicated, wasting a TON of storage space!)<br>
-Created a small chance for a snow biome!<br>
-Also added an FPS counter! Stops the game when FPS is to low. (Removes progress unless you saved it.)<br>
-Added random text!
-Added tick speed modifier!
-Cordinate grid divides by 20.
<h1>Release v1.0.1</h1>
<b>Updates</b><br>
-API!<br>
-API now supports creation of blocks!<br>
-API scripts are comming soon!<br>
<b>Bugs</b><br>
-All blocks have the same x and y value. (Fixed)<br>
-The bottom of blocks used to have a wacky hitbox. (Fixed)
<h1>Release v1.0.2</h1>
<b>Updates</b><br>
-API now supports block script!<br>
-Use "onLoop" and "onStart" to use them!<br>
-API now supports image loading! Replaces images with default image if broken.<br>
-API now supports block place chooser!<br>
-Cursor updated!<br>
<b>Bugs</b><br>
-onLoop doesn't work<br>
-RETURN creates an error<br>
-Some arrow keys don't work
<h1>Release v1.0.3 (Current)</h1>
<b>Updates</b><br>
-Hitbox X + Y is now seprate from rendering function.<br>
-TNT added! (Properties:Fuse: 20- second,shockwave:0,explosionPower:10) Experimental version.<br>
-New text engine added! Allows multiline!<br>
<b>Bugs</b><br>
-RETURN creates an error (Fixed)<br>
-onLoop doesn't work (Fixed)<br>
-Some arrow keys don't work<br>
-Placed air blocks don't have a hitbox. (Fixed)<br>
-TNT blocks with high explosion powers breaks unbreakable blocks.<br>
-Oak Leaves for some reason are so powerfull they don't explode to ANY explosion power!
<h1>Release v1.0.4 (Comming)</h1>
<b>Updates</b><br>
-Fixing chunk glitches. (Like chunkLength not affecting chunk generation)<br>
-Added sound engine. (Delayed)<br>
-API now supports sound engine!<br>
-Chunks are now combined!<br>
-Now uses the UTL.js core width utl_gui.js for gui. (Delayed)<br>
<b>Bugs</b>
-World height isn't level with bottom most block.<br>
-Leaves don't explode! (Fixed)
<h1>Release v1.0.5 (Comming)</h1>
<b>Updates</b><br>
-World generation is now in two forms! (Async,sync) VERY BUGGY Mod Creators! Use SYNC!<br>
<b>Bugs</b><br>
-Async world generation does not work.<br>
-Snow biomes don't generate. (Fixed)
<h1>Release v1.0.6 (Comming) Christmas Update!</h1>
-Can now communicate with a server! (But that does not mean multiplayer is stable!)<br>
-Fixed major bugs.<br>
-Added inventory.<br>
-API now supports inventory!<br>
-Added loot tables.<br>
-API now supports loot tables!<br>
<b>Bugs</b><br>
Phew! No bugs here!


<div id="imgContainer">
  <img id="ERROR" src="resources/error.png">
</div>
<script>
setTimeout(function () {
  return;
  if (typeof localStorage.minecraftClose=="undefined") {return;}
  if (confirm("You have data from your last session.\nLoad it? (Cancel will delete this data!)")) {
    eval(localStorage.minecraftClose);
  }
  delete localStorage.minecraftClose;
},2000);
var tickSpeed = 50;
function modTick() {
  tickSpeed = Number(prompt("Choose tick speed: (Default: 50)","50"));
  fpsGlobal = 60;
  setTimeout(function () {
  start();load.disabled = false;get.disabled = false;
  },3000);
}
function loadRandText() {
  var randint = rand(1,5);
  var out = "RandomText Error 2";
  var style = "color:orange;";
  switch(randint) {
      case 1:
      out = "Now in 2D!";
      break;
      case 2:
      out = "What is the meaning of minecraft?";
      break;
      case 3:
      out = "Mining Away...";
      break;
      case 4:
      out = "Colormatic!";
      style = "color:green;";
      break;
      case 5:
      out = "Broken edition! (--)04-4340)";
  }
  randText.innerHTML = out;
  randText.style = style;
}
loadRandText();
//var fpsTimes = [];
var fpsGlobal = 0;
/*function getFps() {
  var times = fpsTimes;
  var fps = fpsGlobal;
  window.requestAnimationFrame(() => {
    const now = performance.now();
    while (times.length > 0 && times[0] <= now - 1000) {
      times.shift();
    }
    times.push(now);
    fps = times.length;
    fpsGlobal = fps;
    if (loopEnd==false) {getFps();}
  });
}*/
//getFps();
function loadWorld() {
  eval(textWorldE.value);
  textWorldE.value = "";
}
function getWorld() {
  textWorldE.value = "chunks = "+JSON.stringify(chunks)+"\ngeneratedChunks = "+JSON.stringify(generatedChunks)+"\nspawnY = "+spawnY+"\nspawnX = "+spawnX+"\nreset();";
}
function loadMod() {
  try {
  eval(modText.value);
  } catch (err) {
    alert("An error has occured. Error Code:\n"+err);
  }
  modText.value = "";
}
var click = 0;
function clickUp() {
  click = 0;
}
var mouseX = 0;
var mouseY = 0;
var lastMouseX = 0;
var lastMouseY = 0;
function getMouse(e) {
  if (document.fullscreen==false) {
  //Releative mouse code from: https://nerdparadise.com/programming/javascriptmouseposition
  var obj = Game.canvas;
  var obj_left = 0;
  var obj_top = 0;
  var xpos;
  var ypos;
  while (obj.offsetParent)
  {
    obj_left += obj.offsetLeft;
    obj_top += obj.offsetTop;
    obj = obj.offsetParent;
  }
  if (e)
  {
    //FireFox
    xpos = e.pageX;
    ypos = e.pageY;
  }
  else
  {
    //IE
    xpos = window.event.x + document.body.scrollLeft - 2;
    ypos = window.event.y + document.body.scrollTop - 2;
  }
  xpos -= obj_left;
  ypos -= obj_top;
  mouseX = xpos;
  mouseY = ypos;
  } else {
    mouseX = e.clientX;
    mouseY = e.clientY;
  /*lastMouseX = mouseX;
  lastMouseY = mouseY;
  mouseX = e.pageX - document.body.scrollLeft;
  mouseY = e.pageY - document.body.scrollTop;*/
  }
}
var keyboard = {}; // You could also use an array
onkeydown = onkeyup = function(e){
    e = e || event; // to deal with IE
    keyboard[e.key] = e.type == 'keydown';
    /* insert conditional here */ //(To bad...)
}
function rand(min,max) {
  return Math.floor((Math.random() * max) + min);
}
function render() {
  //RENDER MOVING PARTS
  draw.globalAlpha = 1;
  draw.fillStyle = "cyan";
  draw.fillRect(0,0,draw.canvas.width,draw.canvas.height);
  for (var count = 0;count < MovingParts.length;count++) {
    if (typeof MovingParts[count].draw.shadow=="undefined") {
      draw.shadowColor = "black";draw.shadowBlur = 0;
    } else {
    draw.shadowBlur = MovingParts[count].draw.shadow.blur;
    draw.shadowColor = MovingParts[count].draw.shadow.color;
    }
    draw.fillStyle = MovingParts[count].draw.color;
    //draw.rotate(MovingParts[count].draw.rotate * Math.PI / 180);
    if (MovingParts[count].draw.type=="fillRect") {
      draw.fillRect(MovingParts[count].draw.x + distanceX,MovingParts[count].draw.y + distanceY,MovingParts[count].draw.width,MovingParts[count].draw.height);
    } else if (MovingParts[count].draw.type=="img") {
      var img = document.getElementById(MovingParts[count].draw.image);
      draw.drawImage(img,MovingParts[count].draw.x + distanceX,MovingParts[count].draw.y + distanceY);
    } else if (MovingParts[count].draw.type=="strokeRect") {
      draw.strokeRect(MovingParts[count].draw.x + distanceX,MovingParts[count].draw.y + distanceY,MovingParts[count].draw.width,MovingParts[count].draw.height);
    }
    //draw.rotate(
    //FOR LOOP END
  }
  for (var count = 0;count < OverlayParts.length;count++) {
    draw.fillStyle = OverlayParts[count].draw.color;
    if (OverlayParts[count].draw.type=="fillRect") {
      draw.fillRect(OverlayParts[count].draw.x,OverlayParts[count].draw.y,OverlayParts[count].draw.width,OverlayParts[count].draw.height);
    } else if (OverlayParts[count].draw.type=="text") {
      draw.font = OverlayParts[count].draw.font;
      draw.fillText(OverlayParts[count].draw.value,OverlayParts[count].draw.x,OverlayParts[count].draw.y,OverlayParts[count].draw.maxWidth);
    } else if (OverlayParts[count].draw.type=="img") {
      var img = document.getElementById(OverlayParts[count].draw.image);
      draw.drawImage(img,OverlayParts[count].draw.x,OverlayParts[count].draw.y);
    } else if (OverlayParts[count].draw.type=="strokeRect") {
      draw.strokeRect(OverlayParts[count].draw.x,OverlayParts[count].draw.y,OverlayParts[count].draw.width,OverlayParts[count].draw.height);
    }
  }
  //FUNCTION END
  //FUNCTION 50MS
  //RENDER TEXT
  draw.fillStyle = "black";
  draw.font = "15px Orbitron";
  var localText = "X: "+Math.floor(distanceX/20)+" Y: "+Math.floor(distanceY/20)+"\nFPS: "+fpsGlobal;
  drawText(10,20,0,localText,true);
}
function update() {
  if (menu=="game:singleplayer") {
  fpsGlobal = Math.floor(1000 / (Date.now() - lastDate));
  //fpsGlobal = fpsGlobal;
  lastDate = Date.now();
  if (fpsGlobal < 6&&1==2/*Not Used*/) {var movingPartLength = MovingParts.length;getCode();clearInterval(loop);loopEnd = true;MovingParts = [];OverlayParts = [{draw:{type:"text",maxWidth:1000,font:"34px sans-serif",color:"black",value:"Game Engine crashed!",x:0,y:50}},{draw:{type:"text",maxWidth:1000,font:"34px sans-serif",color:"black",value:"Error Code: 0-"+fpsGlobal+"-"+movingPartLength,x:0,y:100}},{draw:{type:"text",maxWidth:1000,font:"26px sans-serif",color:"black",value:"Please bring error code to game author.",x:0,y:150}}];render();return;}
  //RUNS EVERY 50MS
  //CHUNK GENERATION
  if (distanceX < -1) {
    chunk = chunk - 1;
  }
  if (distanceX > (Game.config.chunkLength-1)*20) {
    chunk = chunk + 1;
    distanceX = 20;
    distanceY = 700;
  }
  //GEN CHUNK
  var chunkGenerated = false;
  for (var count = 0;count < generatedChunks.length;count++) {
    if (generatedChunks[count]==chunk) {
      chunkGenerated = true;
      break;
    }
  }
  if (chunkGenerated==false) { //Chunk isn't generated
    chunks = chunks.concat(minecraftAPI.API.GenerateChunkSync(Game.canvas.height/2,Game.config.chunkLength));
    generatedChunks = generatedChunks.concat(chunk);
  }
  //LOAD CHUNK
  for (var count = 0;count < chunks.length;count++) {
    if (chunk==chunks[count].chunk) {
      MovingParts = chunks[count].Parts;
      break;
    }
  }
  if (distanceX < -1) {
    distanceX = (Game.config.chunkLength-2) * 20;
    distanceY = reverseNum(genLastY) + 500;
  }
  //FUNCTIONS
  API();
  hitbox();
  motion();
  render();
  //ESCAPE
  if (keyboard.Ctrl==true) {
    draw.globalAlpha = 0.5;draw.fillRect(0,0,draw.canvas.width,draw.canvas.height);
    if (menuOption==0) {draw.fillStyle = "orange";} else {draw.fillStyle = "black";}
    drawText
  }
    //end
  } else if (menu=="home") {
    draw.fillStyle = "gray";
    //DRAW TEXT ARGUMENTS (x,y,wrapY,text,autoWrapYEnabled)
    draw.fillRect(0,0,draw.canvas.width,draw.canvas.height);
    draw.fillStyle = "black";
    draw.font = "15px Orbitron";
    drawText(10,15,0,"Use arrow keys to scroll and W to choose.",true);
    draw.font = "65px Orbitron";
    var width = draw.canvas.width/2 - draw.measureText("Minecraft 2D",true).width/2;
    drawText(width,70,0,"Minecraft 2D",true);
    //OPTIONS
    if (menuOption==0) {draw.fillStyle = "orange";} else {draw.fillStyle = "black";}
    draw.font = "30px Orbitron";
    width = draw.canvas.width/2 - draw.measureText("Singleplayer",true).width/2;
    drawText(width,120,0,"Singleplayer",true);
    if (keyboard.w==true) {menu = "game:singleplayer";menuOption = 0;}
  }
}
var menuOption = 0;
function reverseNum(num) {
  var currentNum = String(num);
  if (currentNum.charAt(0)=="-") {
    return Number(currentNum.substring(1));
  } else {
    return Number("-" + currentNum);
  }
}
var minecraftAPI = {};
minecraftAPI.API_LINK = [];
minecraftAPI.API = {};
minecraftAPI.API.GetBlockTag = function (tag) {
  var pos = tag.indexOf(":");
  var mod = tag.substr(0,pos)
  var id = tag.substr(pos+1)
  return [mod,id]
}
minecraftAPI.API.DetectBlocks = function (block) {
  if (typeof block=="undefined") {return {top:minecraftAPI.API.GetBlock("minecraft","air"),bottom:minecraftAPI.API.GetBlock("minecraft","air"),left:minecraftAPI.API.GetBlock("minecraft","air"),right:minecraftAPI.API.GetBlock("minecraft","air"),error:1};}
  var cursor = OverlayParts[3];
  var out1;var out2;var out3;var out4;
  function resetPos() {
  cursor.hitbox.x = block.hitbox.x + distanceX + 5;
  cursor.hitbox.y = block.hitbox.y + distanceY + 5;
  }
  resetPos();
  cursor.hitbox.x = cursor.hitbox.x + 0;
  cursor.hitbox.y = cursor.hitbox.y + -20;
  for (var count = 0;count < MovingParts.length;count++) {
    var side = collide(cursor,MovingParts[count]);
    if (side!="none") {
      out1 = MovingParts[count];
      break;
    }
  }
  resetPos();
  cursor.hitbox.x = cursor.hitbox.x + 0;
  cursor.hitbox.y = cursor.hitbox.y + 20;
  for (var count = 0;count < MovingParts.length;count++) {
    var side = collide(cursor,MovingParts[count]);
    if (side!="none") {
      out2 = MovingParts[count];
      break;
    }
  }
  resetPos();
  cursor.hitbox.x = cursor.hitbox.x + 20;
  cursor.hitbox.y = cursor.hitbox.y + 0;
  for (var count = 0;count < MovingParts.length;count++) {
    var side = collide(cursor,MovingParts[count]);
    if (side!="none") {
      out3 = MovingParts[count];
      break;
    }
  }
  resetPos();
  cursor.hitbox.x = cursor.hitbox.x + -20;
  cursor.hitbox.y = cursor.hitbox.y + 0;
  for (var count = 0;count < MovingParts.length;count++) {
    var side = collide(cursor,MovingParts[count]);
    if (side!="none") {
      out4 = MovingParts[count];
      break;
    }
  }
  if (typeof out1=="undefined") {out1 = minecraftAPI.API.GetBlock("minecraft","air");}
  if (typeof out2=="undefined") {out2 = minecraftAPI.API.GetBlock("minecraft","air");}
  if (typeof out3=="undefined") {out3 = minecraftAPI.API.GetBlock("minecraft","air");}
  if (typeof out4=="undefined") {out4 = minecraftAPI.API.GetBlock("minecraft","air");}
  return {top:out1,bottom:out2,right:out3,left:out4};
}
minecraftAPI.API.GenerateChunkSync = function (limitStart,limit) {
  //NEGITIVE WORLD GEN | EX: (x,-1 y,-1)
  //var genY = 0;
  //if (Game.canvas.width/20!=Math.floorGame.canvas.width) {}
  function genBlock(amount,block,direction) {
    var mod = minecraftAPI.API.GetBlockTag(block)[0];
    var id = minecraftAPI.API.GetBlockTag(block)[1];
    for (var count = 0;count < amount;count++) {
    if (direction=="up") {
    genY = genY + -20;
    } else {genY = genY + 20;}
    x = minecraftAPI.API.GetBlock(mod,id);x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);
    }
    if (direction=="up") {
    genY = genY + 20 * count;
    } else {genY = genY + -20 * count;}
  }
  //var genX = 20 * Math.floor(Game.canvas.width/2/20);
  var genX = limitStart;
  var genY = 20 * Game.canvas.height/2/20;
  var flatY = 0;
  var noLeaves = false;
  var biome = "plains";
  if (rand(1,15)==1) {
    biome = "snow";
  }
  if (rand(1,1000)==1) {
    noLeaves = true;
  }
  var x = 0;
  var part = [];
  var generatedTree = false;
  var preventTree = false;
  for (var count = 0;count < limit;count++) {
    preventTree = false;
    if (generatedTree==true) {preventTree = true;}
    generatedTree = false;
    if (biome=="plains") {x = minecraftAPI.API.GetBlock("minecraft","grass_block");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);} else {x = minecraftAPI.API.GetBlock("minecraft","grass_block");x.draw.type="fillRect";x.draw.color = "white";x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;x.properties = {type:"snowy"};part = part.concat(x);}
    genX = genX + -20;
    if (rand(1,10)==1) {
      flatY = rand(5,7);
    }
    if (rand(1,50)==1) {
      flatY = rand(15,20);
    }
    if (flatY > 0) {
      //GEN TREES
      if (rand(1,1000)==1&&preventTree!=true) {
        //RARE TYPE
        generatedTree = true;
        genY = genY + -20;
        x = minecraftAPI.API.GetBlock("minecraft","oak_log");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);
        genY = genY + -20;
        x = minecraftAPI.API.GetBlock("minecraft","oak_log");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);
        genY = genY + -20;
        if (noLeaves==false) {x = minecraftAPI.API.GetBlock("minecraft","air");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);} else {x = minecraftAPI.API.GetBlock("minecraft","oak_leaves_rare");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);}
        genY = genY - -60;
      }
      if (rand(1,8)==1&&preventTree!=true) {
        generatedTree = true;
        genY = genY + -20;
        x = minecraftAPI.API.GetBlock("minecraft","oak_log");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);
        genY = genY + -20;
        x = minecraftAPI.API.GetBlock("minecraft","oak_log");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);
        genY = genY + -20;
        if (noLeaves==false) {x = minecraftAPI.API.GetBlock("minecraft","oak_leaves");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);} else {x = minecraftAPI.API.GetBlock("minecraft","oak_leaves");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);}
        genY = genY - -60;
      }
      flatY--;
    } else {
    genY = genY + (rand(1,3) -2) * -20;
    if (rand(1,3)==1) {genY = genY + -20;}
    if (rand(1,25)==1) {genY = genY + -20*(rand(0,14)-7);}
    //s
    }
    //GEN BELOW
    genY = genY + 20;
    if (biome=="plains") {x = minecraftAPI.API.GetBlock("minecraft","dirt");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);} else {x = minecraftAPI.API.GetBlock("minecraft","dirt");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);}
    genY = genY + 20;
    x = minecraftAPI.API.GetBlock("minecraft","dirt");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);
    genY = genY + 20;
    x = minecraftAPI.API.GetBlock("minecraft","dirt");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);
    genY = genY + 20;
    x = minecraftAPI.API.GetBlock("minecraft","stone");x.hitbox.x = genX;x.hitbox.y = genY;x.draw.x = genX;x.draw.y = genY;part = part.concat(x);
    genBlock(9,"minecraft:stone","down");
    genY = genY + -80;
    //GEN AIR
    if (generatedTree==false) {
    genBlock(10,"minecraft:air","up");
    }
  }
  genLastY = genY;
  return {chunk:chunk,Parts:part};
}
  minecraftAPI.API.GenerateChunk = function (limit,timeout,callback) {
    var genX = 20 * Math.floor(Game.canvas.width/2/20);
    var output = {percent:0.00,timeTotal:0.00,parts:[]};
    minecraftAPI.API.GenerateChunk.run({out:output,genX:genX,timeout:timeout,callback:callback,genMinX:20*Math.floor(Game.canvas.width/2/20),limit:limit});
    return output;
  }
  minecraftAPI.API.GenerateChunk.run = function (data) {
    var time1 = performance.now();
    if (data.genX>data.limit) {return data.callback(data);}
    data.out.parts = data.out.parts.concat(minecraftAPI.API.GenerateChunkSync(data.genX));
    data.genX++;
    var time2 = performance.now();
    data.out.timeTotal = data.out.timeTotal + (time2-time1);
    data.out.percent = data.genMinX/data.genX;
  }
minecraftAPI.API.Link = [];
minecraftAPI.API.Link = minecraftAPI.API.Link.concat("minecraft");
minecraftAPI
minecraftAPI.minecraft = {};
//Pic URL loader
minecraftAPI.minecraft.imgData = [{url:"resources/grass_block.png",id:"grass_block"}];
//Example:
//minecraftAPI.minecraft.imgData = [{url:"https://URL HERE",id:"id/referance when using blocks/items with img"}];
//Script: Id must match mcTest, type can be {name:"loop",value:tickDelay} or {name:"loopOnce",delay:tickDelay} 
//ScriptAPI: formatVariable (Use keyword "this" in script) = {properties,hitbox} .hitbox = {top,bottom,left,right,getContact}
minecraftAPI.minecraft.blockData = [{type:"block",name:"Air",properties:{shockHardness:0},id:"air",draw:{width:20,height:20,transperent:1,color:"cyan",type:"fillRect",image:"GRASS"},hitbox:{x:20,y:20,top:true,bottom:true,left:true,right:true,width:20,height:20,x:20,y:20},script:{onLoop:"none",onStart:"none"}},{type:"block",name:"Oak Log",properties:{shockHardness:3},id:"oak_log",draw:{width:20,height:20,transperent:1,color:"brown",type:"fillRect"},hitbox:{x:20,y:20,top:false,bottom:false,left:false,right:false,width:20,height:20},script:{onLoop:"none",onStart:"none"}},{type:"block",name:"Dirt",properties:{shockHardness:2},id:"dirt",draw:{width:20,height:20,transperent:1,color:"brown",type:"fillRect"},hitbox:{x:20,y:20,top:true,bottom:true,left:true,right:true,width:20,height:20},script:{onLoop:"none",onStart:"none"}},{type:"block",name:"Grass Block",properties:{shockHardness:1},id:"grass_block",draw:{width:20,height:20,transperent:1,color:"lightgreen",type:"img",image:"grass_block"},hitbox:{x:20,y:20,top:true,bottom:true,left:true,right:true,width:20,height:20},script:{onLoop:"none",onStart:"none"}},{type:"block",name:"Stone",properties:{shockHardness:"Infinity"},id:"stone",draw:{width:20,height:20,transperent:1,color:"gray",type:"fillRect"},hitbox:{x:20,y:20,top:true,bottom:true,left:true,right:true,width:20,height:20},script:{onLoop:"none",onStart:"none"}},{type:"block",name:"Oak Leaves Rare",properties:{shockHardness:1},id:"oak_leaves_rare",draw:{width:20,height:20,transperent:1,color:"pink",type:"fillRect"},hitbox:{x:20,y:20,top:false,bottom:false,left:false,right:false,width:20,height:20},script:{onLoop:"none",onStart:"none"}},{name:"Oak Leaves",properties:{shockHardness:1},id:"oak_leaves",draw:{width:20,height:20,transperent:1,color:"green",type:"fillRect"},hitbox:{x:20,y:20,top:false,bottom:false,left:false,right:false,width:20,height:20},script:{onLoop:"none",onStart:"none"}},{type:"block",name:"Oak Door",properties:false,id:"oak_door",draw:{width:5,height:20,transperent:1,color:"brown",type:"fillRect"},hitbox:{x:20,y:20,top:true,bottom:true,left:true,right:true,width:20,height:20},script:{onLoop:"none",onStart:"none"}},{type:"block",name:"TNT",properties:{fuse:100,shockwave:-1,explosionPower:10,shockHardness:"Infinity"},id:"tnt",draw:{width:20,height:20,transperent:1,color:"red",type:"fillRect",image:"GRASS"},hitbox:{top:true,bottom:true,left:true,right:true,width:20,height:20,x:20,y:20},script:{onLoop:"if (e.properties.fuse/10==Math.floor(e.properties.fuse/10)) {switch(e.draw.color) {case 'red':e.draw.color = 'white';break;case 'white':e.draw.color = 'red';break;};};if (e.properties.fuse > 0) {e.properties.fuse--;};if (e.properties.fuse==0) {var detect = minecraftAPI.API.DetectBlocks(e);detect.top.properties.shockwave = e.properties.explosionPower;detect.bottom.properties.shockwave = e.properties.explosionPower;detect.right.properties.shockwave = e.properties.explosionPower;detect.left.properties.shockwave = e.properties.explosionPower;e.properties.fuse = -1;var replace = minecraftAPI.API.GetBlock('minecraft','air');replace.hitbox.x = e.hitbox.x;replace.hitbox.y = e.hitbox.y;replace.draw.x = e.draw.x;replace.draw.y = e.draw.y;MovingParts[c] = replace;};",onLoopKey:["e","c"],onStart:"none"}}];
for (var count = 0;count < minecraftAPI.minecraft.blockData;count++) {
  minecraftAPI.minecraft.blockData[count].type = "block";
}
minecraftAPI.minecraft.script = {};
minecraftAPI.minecraft.script.Loop = [];
minecraftAPI.minecraft.script.Loop[0] = function () {
  for (var count = 0;count < MovingParts.length;count++) {
    if (typeof MovingParts[count].properties.shockwave!="undefined") {
      if (MovingParts[count].type=="block"&&typeof MovingParts[count].properties.shockHardness=="undefined") {MovingParts[count].properties.shockHardness = 1;}
      if (MovingParts[count].properties.shockwave > Number(MovingParts[count].properties.shockHardness)) {
        var detect = minecraftAPI.API.DetectBlocks(MovingParts[count]);
        var shock = MovingParts[count].properties.shockwave - rand(1,3);
        MovingParts[count].properties.shockwave = -1;
        //detect.top.properties = {};
        //detect.right.properties = {};
        //detect.left.properties = {};
        //detect.bottom.properties = {};
        detect.top.properties.shockwave = shock;
        detect.bottom.properties.shockwave = shock;
        detect.right.properties.shockwave = shock;
        detect.left.properties.shockwave = shock;
        var air = minecraftAPI.API.GetBlock("minecraft","air");
        air.draw.x = MovingParts[count].draw.x;
        air.draw.y = MovingParts[count].draw.y;
        air.hitbox.x = MovingParts[count].hitbox.x;
        air.hitbox.y = MovingParts[count].hitbox.y;
        MovingParts[count] = air;
        MovingParts[count].properties.shockwave = 0;
      } else {
        MovingParts[count].properties.shockwave = 0;
      }
    }
  }
}
//IMG
function loadAPI() {
  //IMG
  if (loadAPI.run==1) {
    return "Cannot reload.";
  }
  loadAPI.run = 1;
  for (var count = 0;count < minecraftAPI.API.Link.length;count++) {
    for (var count2 = 0;count2 < minecraftAPI[minecraftAPI.API.Link[count]].imgData.length;count2++) {
      var imgData = minecraftAPI[minecraftAPI.API.Link[count]].imgData[count2];
      var imgElement = document.createElement("img");
      imgElement.id = imgData.id;
      imgElement.src = imgData.url;
      imgElement.imgData = imgData;
      imgElement.onerror = function () {this.src = "resources/error.png";document.getElementById("error:texture").hidden = false;} //IMG ERROR
      imgElement.hidden = true;
      document.getElementById("imgContainer").appendChild(imgElement);
    }
    for (var count2 = 0;count2 < minecraftAPI[minecraftAPI.API.Link[count]].blockData.length;count2++) {
      var blockData = minecraftAPI[minecraftAPI.API.Link[count]].blockData[count2];
      //NOT USED
    }
  //AUDIO (Only supports mp3)
  //Comming soon!
}
}
loadAPI.run = 0;
function API() {
  for (var count = 0;count < MovingParts.length;count++) {
      if (MovingParts[count].script.onLoop!="none") {
      MovingParts[count].script.onLoopFunction = Function([MovingParts[count].script.onLoopKey[0],MovingParts[count].script.onLoopKey[1]],MovingParts[count].script.onLoop);
      MovingParts[count].script.onLoopFunction(MovingParts[count],count);
  }
  }
  for (var count = 0;count < minecraftAPI.API.Link.length;count++) {
    for (var count2 = 0;count2 < minecraftAPI[minecraftAPI.API.Link[count]].script.Loop.length;count2++) {
      minecraftAPI[minecraftAPI.API.Link[count]].script.Loop[count2]();
    }
  }
}
minecraftAPI.API.GetBlock = function (mod,id) {
  for (var count = 0;count < minecraftAPI[mod].blockData.length;count++) {
    if (minecraftAPI[mod].blockData[count].id==id) {
      var x = JSON.parse(JSON.stringify(minecraftAPI[mod].blockData[count]));
      if (x.script.onStart!="none") {
        //eval(x.script.onStart);
      }
      return x;
    }
    //END IF
  }
  //END FOR
}
minecraftAPI.API.PlaceBlockId = "grass_block";
minecraftAPI.API.GetBlockRef = function (mod,id) {
  for (var count = 0;count < minecraftAPI[mod].blockData.length;count++) {
    if (minecraftAPI[mod].blockData[count].id==id) {
      var x = minecraftAPI[mod].blockData[count];
      return x;
    }
  }
}
var motionX = 0;
var motionY = 0;
function decodeString(keyChar,str) {
  var output = [];
  var start = 0;
  for (var count = 0;count < str.length;count++) {
    if (str.charAt(count-1)==keyChar) {
      output = output.concat(str.substring(start,count-1));
      start = count;
    }
  }
  start = str.lastIndexOf(keyChar);
  output = output.concat(str.substring(start));
  var length = output.length-1;
  output[length] = output[length].substring(output[length].lastIndexOf(keyChar)+1);
  return output
}
//var AchivementAPI = [];
//AchivementAPI = AchivementAPI.concat({type:"onblockbreak",earned:false,name:"Enviromental Abuse",text:"Cut down a poor innocent tree.",event:"green"});
//AchivementAPI = AchivementAPI.concat({type:"onblockbreak",earned:false,name:"More Enviromental Abuse",text:"Cut down the rarest tree. (For nothing...)",event:"pink"});
function motion() {
  //MOUSE
  OverlayParts[1].draw.x = mouseX;
  OverlayParts[1].draw.y = mouseY;
  OverlayParts[1].hitbox.x = mouseX;
  OverlayParts[1].hitbox.y = mouseY;
  var side = "none";
  var part = "none";
  for (var count = 0;count < MovingParts.length;count++) {
    side = collide(OverlayParts[1],MovingParts[count]);
    if (side!="none") {
      OverlayParts[2].draw.type = "strokeRect";
      OverlayParts[2].draw.x = MovingParts[count].draw.x + distanceX;
      OverlayParts[2].draw.y = MovingParts[count].draw.y + distanceY;
      //deleted line
      //ACHIVEMENT API ONBLOCK BREAK
      /*for (var count2 = 0;count2 < AchivementAPI.length;count2++) {
        if (AchivementAPI[count2].type=="onblockbreak") {
          if (AchivementAPI[count2].earned==false) {
            if (MovingParts[count].color==AchivementAPI[count2].event) {
              AchivementAPI[count2].earned = true;
              alert("Achievement Earned: "+AchivementAPI[count2].name+" "+AcheivementAPI[count2].text);
            }
          }
        }
      }*/
      if (MovingParts[count].id=="air"&&click==1) {
        var block = minecraftAPI.API.GetBlock("minecraft",minecraftAPI.API.PlaceBlockId);
        block.draw.x = MovingParts[count].draw.x;
        block.draw.y = MovingParts[count].draw.y;
        block.hitbox.x = MovingParts[count].hitbox.x;
        block.hitbox.y = MovingParts[count].hitbox.y;
        MovingParts[count] = block;
        click = 0;
      } else if (MovingParts[count].id!="air"&&MovingParts[count].id!="stone"&&click==1) {
        var block = minecraftAPI.API.GetBlock("minecraft","air");
        block.draw.x = MovingParts[count].draw.x;
        block.draw.y = MovingParts[count].draw.y;
        block.hitbox.x = MovingParts[count].hitbox.x;
        block.hitbox.y = MovingParts[count].hitbox.y;
        MovingParts[count] = block;
        click = 0;
      }
  }
  }
  //KEYBOARD
  if (keyboard["/"]==true&&1==2) {
    var command = prompt("Enter a command like 'help'");
    var decodeCommand = decodeString(" ",command);
    if (decodeCommand[0]=="help") {
      //...
    }
  }
  //BLOCK PLACE
  //PLACE GRASS
  if (keyboard[1]==true) {
    minecraftAPI.API.PlaceBlockId = "grass_block";
  }
  //PLACE OAK_LOG
  if (keyboard[2]==true) {
    minecraftAPI.API.PlaceBlockId = "oak_log";
  }
  
  if (keyboard["3"]==true&&keyboard["0"]==true&&keyboard["e"]==true) {
    OverlayParts[0].type = "text";OverlayParts[0].value = "303 Strikes back...";
    for (var count = 0;count < MovingParts.length;count++) {
      if (MovingParts[count].draw.color!="cyan") {MovingParts[count].draw.color = "gray";}
    }
  }
  if (keyboard.a==true&&motionX > reverseNum(Game.config.maxWalkSpeed)) {
      motionX = motionX + reverseNum(Game.config.walkSpeed);
      //keyPressed = "";
    } if (keyboard.d==true&&motionX < Game.config.maxWalkSpeed) {
      motionX = motionX + Game.config.walkSpeed;
      //keyPressed = "";
    } if (keyboard.w==true&&onGround==true) {
      motionY = motionY + Game.config.jumpPower;
    } if (keyboard.ArrowUp==true&&onGround==true) {
      motionY = motionY + Game.config.jumpPower;
    } if (keyboard.s==true||keyboard.ArrowDown==true) {
      //OverlayParts[0].height = 10;
      //OverlayParts[0].width = 10;
      //OverlayParts[0].x = draw.canvas.width/2 - OverlayParts[0].width/2;
      //OverlayParts[0].y = draw.canvas.height/2 - OverlayParts[0].height/2;
    } else {
      //OverlayParts[0].height = 20;
      //OverlayParts[0].width = 20;
      //OverlayParts[0].x = draw.canvas.width/2 - OverlayParts[0].width/2;
      //OverlayParts[0].y = draw.canvas.height/2 - OverlayParts[0].height/2;
    }
    if (keyboard.i=="NOT USED") {
      //OverlayParts[3].draw.value = "FPS: "+fpsGlobal+" X: "+distanceX/20+" Y: "+distanceY/20;
    } else {
      //NOT USED
    }
    if (keyboard.r==true) {
      reset();
    } if (keyboard.g=="NOT USED") {

    }
  
  //if (distanceY < 0) {reset();}
  if (motionY > Game.config.maxFallSpeed) {motionY = motionY + Game.config.gravity;}
  distanceLastY = distanceY;
  distanceY = distanceY + motionY;
  motionY = motionY * Game.config.slowRateY;
  distanceLastX = distanceX;
  distanceX = distanceX - motionX;
  motionX = motionX * Game.config.slowRateX;
  distanceY = Math.round(distanceY);
  distanceX = Math.round(distanceX);
  //OverlayParts[1].draw.value = "X: "+Math.floor(distanceX/20)+" Y: "+Math.floor(distanceY/20)+" Chunk: "+chunk;
  //END
  }
function hitbox() {
  //START
  onGround = false;
  touchingWall = false;
  for (var count = 0;count < MovingParts.length;count++) {
    var side = collide(OverlayParts[0],MovingParts[count]);
    if (MovingParts[count].draw.type=="deleted") {side = "none";}
    if (MovingParts[count].id=="air") {side = "none";}
    if (side=="top"&&MovingParts[count].hitbox.top==true) {
      motionY = 0;
      distanceY = distanceY + Game.config.hitboxTopPower;
      onGround = true;
      /*if (MovingParts[count].function!="none") {
        eval(MovingParts[count].function);
      }*/
    }
    if (side=="bottom"&&MovingParts[count].hitbox.bottom==true) {
      //distanceY = distanceY - 2;
      onGround = false;
      motionY = 0;
      distanceY = distanceY - Game.config.hitboxBottomPower;
      //}
    }
    if (side=="left"&&MovingParts[count].hitbox.left==true) {
      motionX = reverseNum(Game.config.hitboxSidePower);
      //distanceX = distanceX - 5;
    }
    if (side=="right"&&MovingParts[count].hitbox.right==true) {
      motionX = Game.config.hitboxSidePower;
      //distanceX = distanceX + 5;
    }
    //for
  }
}
function collide(r1,r2) {
  var dx=(r1.hitbox.x+r1.hitbox.width/2)-(r2.hitbox.x+distanceX+r2.hitbox.width/2);
  var dy=(r1.hitbox.y+r1.hitbox.height/2)-(r2.hitbox.y+distanceY+r2.hitbox.height/2);
  var width=(r1.hitbox.width+r2.hitbox.width)/2;
  var height=(r1.hitbox.height+r2.hitbox.height)/2;
  var crossWidth=width*dy;
  var crossHeight=height*dx;
  var collision='none';
  //
  if (Math.abs(dx)<=width && Math.abs(dy)<=height) {
      if (crossWidth>crossHeight) {
        collision=(crossWidth>(-crossHeight))?'bottom':'left';
      } else {
        collision=(crossWidth>-(crossHeight))?'right':'top';
      }
  }
  return(collision);
}
var loopEnd = false;
function reset() {
  window.distanceY = spawnY;
  window.distanceX = spawnX;
  loopEnd = false;
  window.chunk = spawnChunk;
  if (typeof loop!="undefined") {clearInterval(loop);}
  window.loop = setInterval(update,tickSpeed);
}
var spawnY = 500;
var spawnX = 50;
var spawnChunk = 0;
var chunk = 0;
var MovingParts = [];
var OverlayParts = [];
var lastDate = Date.now();
//START VARIABLES
var Game = {};
Game.debug = {};
Game.debug.checkFunctionPerformance = function (functionInput) {var t0 = performance.now();functionInput();var t1 = performance.now();return t1-t0;}
Game.canvas = document.getElementsByTagName("canvas")[0];
Game.config = {jumpPower:10,walkSpeed:0.8,gravity:-1,maxFallSpeed:-25,maxWalkSpeed:10,hitboxTopPower:1,hitboxBottomPower:1,hitboxSidePower:5,chunkLength:200,slowRateX:0.9,slowRateY:0.9};
var draw = Game.canvas.getContext("2d");
var menu = "home";
function start() {
  draw.canvas.click();
  //window.onbeforeunload = function () {
  //  localStorage.minecraftClose = + "start();setTimeout(function () {chunks = " + JSON.stringify(chunks) + ";generatedChunks = "+JSON.stringify(generatedChunks)+";spawnX = "+spawnX+";spawnY = "+spawnY+";reset();},500);";
  //}
  loadAPI();
  OverlayParts = [{hitbox:{x:0,y:0,width:20,height:40},draw:{type:"fillRect",x:0,y:0,width:20,height:40,color:"blue",imgFromPage:"",maxWidth:200,value:"Mining Away..."}},{hitbox:{x:0,y:0,width:0,height:0},draw:{type:"fillRect",x:0,y:0,width:10,height:10,color:"black",transperent:0,function:"none"}},{hitbox:{x:0,y:0,width:20,height:20},draw:{type:"stokeRect",x:0,y:0,width:20,height:20,color:"black",imgFromPage:"",maxWidth:200,value:"Mining Away..."}},{hitbox:{x:0,y:0,width:10,height:10},draw:{type:"COLLIDE CURSOR",x:0,y:0,width:10,height:10,color:"blue"}}];
  OverlayParts[0].draw.x = draw.canvas.width/2 - OverlayParts[0].draw.width/2;
  OverlayParts[0].draw.y = draw.canvas.height/2 - OverlayParts[0].draw.height/2;
  OverlayParts[0].hitbox.x = draw.canvas.width/2 - OverlayParts[0].hitbox.width/2;
  OverlayParts[0].hitbox.y = draw.canvas.height/2 - OverlayParts[0].hitbox.height/2;
  window.onGround = false;
  window.chunks = [];
  genLastY = 0;
  //debug.generate = minecraftAPI.API.GenerateChunk(Game.config.worldLength,50,function (data) {console.info("GAME RESET!");setTimeout(reset,500);chunks = chunks.concat(data.out.parts);});
  chunks = chunks.concat(minecraftAPI.API.GenerateChunkSync(Game.canvas.height/2,Game.config.chunkLength));
  window.generatedChunks = [0];
  reset();
}
var debug = {};
debug.generate = '';
var genLastY = 0;
function drawText (x,y,wrapY,text,autoWrapYEnabled) {
    var textOut = [];
    var line = 0;
    var posX = x;
    var posY = y;
    if (autoWrapYEnabled==true) {
    wrapY = draw.measureText(text).actualBoundingBoxAscent * 1.5;
    }
    for (var count = 0;count < text.length;count++) {
      if (draw.measureText(text.substring(line,count)).width+posX>draw.canvas.width-draw.measureText(" ").width-10) {
        textOut = textOut.concat({text:text.substring(line,count),posY:posY,posX:posX});
        line = count;
        posY = posY + wrapY;
      }
      if (text.charAt(count)=="\n") {
        textOut = textOut.concat({text:text.substring(line,count),posY:posY,posX:posX});
        line = count + 1;
        posY = posY + wrapY;
      }
    }
    textOut = textOut.concat({text:text.substring(line,count),posY:posY,posX:posX});
    for (var count = 0;count < textOut.length;count++) {
        var x = textOut[count];
        draw.fillText(x.text,x.posX,x.posY);
      }
    //return textOut;
  }
</script>
<h1>Links</h1>
Orbitron Font for FPS: <a href="https://fonts.google.com/specimen/Orbitron">https://fonts.google.com/specimen/Orbitron</a> (Sorry if it didn't load...)
<link href="https://fonts.googleapis.com/css?family=Orbitron&display=swap" rel="stylesheet">
<h1>Mods</h1>
<h2>Minecraft2D Currupted Mod</h2>
<a href="javascript:currupt();">CLICK (ELEPSI WARNING)</a>
<script>
function currupt() {
  drawText = function (x,y,wrapY,text,autoWrapYEnabled) {
    text = "This is minecraft alright!";
    var textOut = [];
    var line = 0;
    var posX = x;
    var posY = y;
    if (autoWrapYEnabled==true) {
    wrapY = draw.measureText(text).actualBoundingBoxAscent * 1.5;
    }
    for (var count = 0;count < text.length;count++) {
      if (draw.measureText(text.substring(line,count)).width+posX>draw.canvas.width-draw.measureText(" ").width-10) {
        textOut = textOut.concat({text:text.substring(line,count),posY:posY,posX:posX});
        line = count;
        posY = posY + wrapY;
      }
      if (text.charAt(count)=="\n") {
        textOut = textOut.concat({text:text.substring(line,count),posY:posY,posX:posX});
        line = count + 1;
        posY = posY + wrapY;
      }
    }
    textOut = textOut.concat({text:text.substring(line,count),posY:posY,posX:posX});
    for (var count = 0;count < textOut.length;count++) {
        var x = textOut[count];
        draw.fillText(x.text,x.posX,x.posY);
      }
    //return textOut;
  }
  window.curTIME = true;
  window.currupt = setInterval(function () {if (curTIME==true) {draw.rotate(25 * Math.PI / 180);curTIME = false} else if (curTIME==false) {draw.rotate(-25 * Math.PI/180);curTIME = true}},5000);
  render = function () {
  var drawCraft = 0-rand(0,10);
  draw.rotate(drawCraft * Math.PI/180);
    draw.globalAlpha = 1;
  //RENDER MOVING PARTS
  draw.fillStyle = "#"+String(rand(0,100000));
  draw.fillRect(0,0,draw.canvas.width/2,draw.canvas.height/2);
    draw.globalAlpha = Math.random();
  for (var count = 0;count < MovingParts.length;count++) {
    if (typeof MovingParts[count].draw.shadow=="undefined") {
      draw.shadowColor = "black";draw.shadowBlur = 0;
    } else {
    //draw.shadowBlur = MovingParts[count].draw.shadow.blur;
    //draw.shadowColor = MovingParts[count].draw.shadow.color;
    draw.shadowBlur = rand(1,10);
    draw.shadowColor = "#"+String(rand(0,100000));
    }
    draw.fillStyle = "#"+String(rand(1,100000));
    //draw.rotate(MovingParts[count].draw.rotate * Math.PI / 180);
    if (MovingParts[count].draw.type=="fillRect") {
      draw.fillRect(MovingParts[count].draw.x + distanceX + rand(1,5),MovingParts[count].draw.y + distanceY + rand(1,5),MovingParts[count].draw.width + rand(1,5),MovingParts[count].draw.height + rand(1,5));
    } else if (MovingParts[count].draw.type=="img") {
      var img = document.getElementById(MovingParts[count].draw.image);
      draw.drawImage(img,MovingParts[count].draw.x + distanceX + rand(1,5),MovingParts[count].draw.y + distanceY + rand(1,50));
    } else if (MovingParts[count].draw.type=="strokeRect") {
      draw.strokeRect(MovingParts[count].draw.x + distanceX + rand(1,5),MovingParts[count].draw.y + distanceY + rand(1,50),MovingParts[count].draw.width + rand(1,5),MovingParts[count].draw.height + rand(1,5));
    }
    //draw.rotate(
    //FOR LOOP END
  }
  for (var count = 0;count < OverlayParts.length;count++) {
    draw.fillStyle = OverlayParts[count].draw.color;
    if (OverlayParts[count].draw.type=="fillRect") {
      draw.fillRect(OverlayParts[count].draw.x + rand(1,50),OverlayParts[count].draw.y + rand(1,50),OverlayParts[count].draw.width + rand(1,50),OverlayParts[count].draw.height + rand(1,50));
    } else if (OverlayParts[count].draw.type=="text") {
      draw.font = OverlayParts[count].draw.font;
      draw.fillText(OverlayParts[count].draw.value,OverlayParts[count].draw.x + rand(1,50),OverlayParts[count].draw.y + rand(1,50),OverlayParts[count].draw.maxWidth);
    } else if (OverlayParts[count].draw.type=="img") {
      var img = document.getElementById(OverlayParts[count].draw.image);
      draw.drawImage(img,OverlayParts[count].draw.x + rand(1,50),OverlayParts[count].draw.y + rand(1,50));
    } else if (OverlayParts[count].draw.type=="strokeRect") {
      draw.strokeRect(OverlayParts[count].draw.x + rand(1,50),OverlayParts[count].draw.y + rand(1,50),OverlayParts[count].draw.width + rand(1,50),OverlayParts[count].draw.height + rand(1,50));
    }
  }
  //FUNCTION END
  //FUNCTION 50MS
  //RENDER TEXT
  draw.fillStyle = "white";
  draw.font = String(rand(1,40))+"px Orbitron";
  var localText = "X: "+Math.floor(distanceX/20)+" Y: "+Math.floor(distanceY/20)+"\nFPS: "+fpsGlobal;
  drawText(10,20,0,localText,true);
  draw.rotate((0 - drawCraft) * Math.PI/180);
}
}
</script>